{
  "server": {
    "component": "'use strict';\n\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\n\n/* public/index.html generated by Svelte v3.42.4 */\n\nconst Public = create_ssr_component(($$result, $$props, $$bindings, slots) => {\n\treturn `<!DOCTYPE html>\n<html lang=\"${\"en\"}\"><head><meta charset=\"${\"utf-8\"}\">\n    <meta name=\"${\"viewport\"}\" content=\"${\"width=device-width,initial-scale=1\"}\">\n\n    <link rel=\"${\"icon\"}\" type=\"${\"image/png\"}\" href=\"${\"/favicon.png\"}\">\n    <link rel=\"${\"stylesheet\"}\" href=\"${\"/global.css\"}\">\n    <link rel=\"${\"stylesheet\"}\" href=\"${\"/build/bundle.css\"}\">\n\n    <script defer src=\"${\"/build/bundle.js\"}\"></script></head>\n\n  <body></body>\n  <script src=\"${\"http://code.jquery.com/jquery-latest.min.js\"}\"></script>\n  <script src=\"${\"../chat.js\"}\"></script></html>`;\n});\n\nmodule.exports = Public;\n"
  },
  "client": {
    "js": {
      "code": "var Index = (function () {\n    'use strict';\n\n    function noop() { }\n    function add_location(element, file, line, column, char) {\n        element.__svelte_meta = {\n            loc: { file, line, column, char }\n        };\n    }\n    function run(fn) {\n        return fn();\n    }\n    function blank_object() {\n        return Object.create(null);\n    }\n    function run_all(fns) {\n        fns.forEach(run);\n    }\n    function is_function(thing) {\n        return typeof thing === 'function';\n    }\n    function safe_not_equal(a, b) {\n        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n    }\n    let src_url_equal_anchor;\n    function src_url_equal(element_src, url) {\n        if (!src_url_equal_anchor) {\n            src_url_equal_anchor = document.createElement('a');\n        }\n        src_url_equal_anchor.href = url;\n        return element_src === src_url_equal_anchor.href;\n    }\n    function is_empty(obj) {\n        return Object.keys(obj).length === 0;\n    }\n\n    // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n    // at the end of hydration without touching the remaining nodes.\n    let is_hydrating = false;\n    function start_hydrating() {\n        is_hydrating = true;\n    }\n    function end_hydrating() {\n        is_hydrating = false;\n    }\n    function upper_bound(low, high, key, value) {\n        // Return first index of value larger than input value in the range [low, high)\n        while (low < high) {\n            const mid = low + ((high - low) >> 1);\n            if (key(mid) <= value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    function init_hydrate(target) {\n        if (target.hydrate_init)\n            return;\n        target.hydrate_init = true;\n        // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n        let children = target.childNodes;\n        // If target is <head>, there may be children without claim_order\n        if (target.nodeName === 'HEAD') {\n            const myChildren = [];\n            for (let i = 0; i < children.length; i++) {\n                const node = children[i];\n                if (node.claim_order !== undefined) {\n                    myChildren.push(node);\n                }\n            }\n            children = myChildren;\n        }\n        /*\n        * Reorder claimed children optimally.\n        * We can reorder claimed children optimally by finding the longest subsequence of\n        * nodes that are already claimed in order and only moving the rest. The longest\n        * subsequence subsequence of nodes that are claimed in order can be found by\n        * computing the longest increasing subsequence of .claim_order values.\n        *\n        * This algorithm is optimal in generating the least amount of reorder operations\n        * possible.\n        *\n        * Proof:\n        * We know that, given a set of reordering operations, the nodes that do not move\n        * always form an increasing subsequence, since they do not move among each other\n        * meaning that they must be already ordered among each other. Thus, the maximal\n        * set of nodes that do not move form a longest increasing subsequence.\n        */\n        // Compute longest increasing subsequence\n        // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n        const m = new Int32Array(children.length + 1);\n        // Predecessor indices + 1\n        const p = new Int32Array(children.length);\n        m[0] = -1;\n        let longest = 0;\n        for (let i = 0; i < children.length; i++) {\n            const current = children[i].claim_order;\n            // Find the largest subsequence length such that it ends in a value less than our current value\n            // upper_bound returns first greater value, so we subtract one\n            // with fast path for when we are on the current longest subsequence\n            const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n            p[i] = m[seqLen] + 1;\n            const newLen = seqLen + 1;\n            // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n            m[newLen] = i;\n            longest = Math.max(newLen, longest);\n        }\n        // The longest increasing subsequence of nodes (initially reversed)\n        const lis = [];\n        // The rest of the nodes, nodes that will be moved\n        const toMove = [];\n        let last = children.length - 1;\n        for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n            lis.push(children[cur - 1]);\n            for (; last >= cur; last--) {\n                toMove.push(children[last]);\n            }\n            last--;\n        }\n        for (; last >= 0; last--) {\n            toMove.push(children[last]);\n        }\n        lis.reverse();\n        // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n        toMove.sort((a, b) => a.claim_order - b.claim_order);\n        // Finally, we move the nodes\n        for (let i = 0, j = 0; i < toMove.length; i++) {\n            while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n                j++;\n            }\n            const anchor = j < lis.length ? lis[j] : null;\n            target.insertBefore(toMove[i], anchor);\n        }\n    }\n    function append_hydration(target, node) {\n        if (is_hydrating) {\n            init_hydrate(target);\n            if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n                target.actual_end_child = target.firstChild;\n            }\n            // Skip nodes of undefined ordering\n            while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n                target.actual_end_child = target.actual_end_child.nextSibling;\n            }\n            if (node !== target.actual_end_child) {\n                // We only insert if the ordering of this node should be modified or the parent node is not target\n                if (node.claim_order !== undefined || node.parentNode !== target) {\n                    target.insertBefore(node, target.actual_end_child);\n                }\n            }\n            else {\n                target.actual_end_child = node.nextSibling;\n            }\n        }\n        else if (node.parentNode !== target || node.nextSibling !== null) {\n            target.appendChild(node);\n        }\n    }\n    function insert_hydration(target, node, anchor) {\n        if (is_hydrating && !anchor) {\n            append_hydration(target, node);\n        }\n        else if (node.parentNode !== target || node.nextSibling != anchor) {\n            target.insertBefore(node, anchor || null);\n        }\n    }\n    function detach(node) {\n        node.parentNode.removeChild(node);\n    }\n    function element(name) {\n        return document.createElement(name);\n    }\n    function text(data) {\n        return document.createTextNode(data);\n    }\n    function space() {\n        return text(' ');\n    }\n    function attr(node, attribute, value) {\n        if (value == null)\n            node.removeAttribute(attribute);\n        else if (node.getAttribute(attribute) !== value)\n            node.setAttribute(attribute, value);\n    }\n    function children(element) {\n        return Array.from(element.childNodes);\n    }\n    function init_claim_info(nodes) {\n        if (nodes.claim_info === undefined) {\n            nodes.claim_info = { last_index: 0, total_claimed: 0 };\n        }\n    }\n    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n        // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n        init_claim_info(nodes);\n        const resultNode = (() => {\n            // We first try to find an element after the previous one\n            for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    return node;\n                }\n            }\n            // Otherwise, we try to find one before\n            // We iterate in reverse so that we don't go too far back\n            for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (predicate(node)) {\n                    const replacement = processNode(node);\n                    if (replacement === undefined) {\n                        nodes.splice(i, 1);\n                    }\n                    else {\n                        nodes[i] = replacement;\n                    }\n                    if (!dontUpdateLastIndex) {\n                        nodes.claim_info.last_index = i;\n                    }\n                    else if (replacement === undefined) {\n                        // Since we spliced before the last_index, we decrease it\n                        nodes.claim_info.last_index--;\n                    }\n                    return node;\n                }\n            }\n            // If we can't find any matching node, we create a new one\n            return createNode();\n        })();\n        resultNode.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n        return resultNode;\n    }\n    function claim_element_base(nodes, name, attributes, create_element) {\n        return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n            const remove = [];\n            for (let j = 0; j < node.attributes.length; j++) {\n                const attribute = node.attributes[j];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            remove.forEach(v => node.removeAttribute(v));\n            return undefined;\n        }, () => create_element(name));\n    }\n    function claim_element(nodes, name, attributes) {\n        return claim_element_base(nodes, name, attributes, element);\n    }\n    function claim_text(nodes, data) {\n        return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n            const dataStr = '' + data;\n            if (node.data.startsWith(dataStr)) {\n                if (node.data.length !== dataStr.length) {\n                    return node.splitText(dataStr.length);\n                }\n            }\n            else {\n                node.data = dataStr;\n            }\n        }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n        );\n    }\n    function claim_space(nodes) {\n        return claim_text(nodes, ' ');\n    }\n    function custom_event(type, detail, bubbles = false) {\n        const e = document.createEvent('CustomEvent');\n        e.initCustomEvent(type, bubbles, false, detail);\n        return e;\n    }\n\n    let current_component;\n    function set_current_component(component) {\n        current_component = component;\n    }\n\n    const dirty_components = [];\n    const binding_callbacks = [];\n    const render_callbacks = [];\n    const flush_callbacks = [];\n    const resolved_promise = Promise.resolve();\n    let update_scheduled = false;\n    function schedule_update() {\n        if (!update_scheduled) {\n            update_scheduled = true;\n            resolved_promise.then(flush);\n        }\n    }\n    function add_render_callback(fn) {\n        render_callbacks.push(fn);\n    }\n    let flushing = false;\n    const seen_callbacks = new Set();\n    function flush() {\n        if (flushing)\n            return;\n        flushing = true;\n        do {\n            // first, call beforeUpdate functions\n            // and update components\n            for (let i = 0; i < dirty_components.length; i += 1) {\n                const component = dirty_components[i];\n                set_current_component(component);\n                update(component.$$);\n            }\n            set_current_component(null);\n            dirty_components.length = 0;\n            while (binding_callbacks.length)\n                binding_callbacks.pop()();\n            // then, once components are updated, call\n            // afterUpdate functions. This may cause\n            // subsequent updates...\n            for (let i = 0; i < render_callbacks.length; i += 1) {\n                const callback = render_callbacks[i];\n                if (!seen_callbacks.has(callback)) {\n                    // ...so guard against infinite loops\n                    seen_callbacks.add(callback);\n                    callback();\n                }\n            }\n            render_callbacks.length = 0;\n        } while (dirty_components.length);\n        while (flush_callbacks.length) {\n            flush_callbacks.pop()();\n        }\n        update_scheduled = false;\n        flushing = false;\n        seen_callbacks.clear();\n    }\n    function update($$) {\n        if ($$.fragment !== null) {\n            $$.update();\n            run_all($$.before_update);\n            const dirty = $$.dirty;\n            $$.dirty = [-1];\n            $$.fragment && $$.fragment.p($$.ctx, dirty);\n            $$.after_update.forEach(add_render_callback);\n        }\n    }\n    const outroing = new Set();\n    function transition_in(block, local) {\n        if (block && block.i) {\n            outroing.delete(block);\n            block.i(local);\n        }\n    }\n    function mount_component(component, target, anchor, customElement) {\n        const { fragment, on_mount, on_destroy, after_update } = component.$$;\n        fragment && fragment.m(target, anchor);\n        if (!customElement) {\n            // onMount happens before the initial afterUpdate\n            add_render_callback(() => {\n                const new_on_destroy = on_mount.map(run).filter(is_function);\n                if (on_destroy) {\n                    on_destroy.push(...new_on_destroy);\n                }\n                else {\n                    // Edge case - component was destroyed immediately,\n                    // most likely as a result of a binding initialising\n                    run_all(new_on_destroy);\n                }\n                component.$$.on_mount = [];\n            });\n        }\n        after_update.forEach(add_render_callback);\n    }\n    function destroy_component(component, detaching) {\n        const $$ = component.$$;\n        if ($$.fragment !== null) {\n            run_all($$.on_destroy);\n            $$.fragment && $$.fragment.d(detaching);\n            // TODO null out other refs, including component.$$ (but need to\n            // preserve final state?)\n            $$.on_destroy = $$.fragment = null;\n            $$.ctx = [];\n        }\n    }\n    function make_dirty(component, i) {\n        if (component.$$.dirty[0] === -1) {\n            dirty_components.push(component);\n            schedule_update();\n            component.$$.dirty.fill(0);\n        }\n        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n    }\n    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n        const parent_component = current_component;\n        set_current_component(component);\n        const $$ = component.$$ = {\n            fragment: null,\n            ctx: null,\n            // state\n            props,\n            update: noop,\n            not_equal,\n            bound: blank_object(),\n            // lifecycle\n            on_mount: [],\n            on_destroy: [],\n            on_disconnect: [],\n            before_update: [],\n            after_update: [],\n            context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n            // everything else\n            callbacks: blank_object(),\n            dirty,\n            skip_bound: false,\n            root: options.target || parent_component.$$.root\n        };\n        append_styles && append_styles($$.root);\n        let ready = false;\n        $$.ctx = instance\n            ? instance(component, options.props || {}, (i, ret, ...rest) => {\n                const value = rest.length ? rest[0] : ret;\n                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                    if (!$$.skip_bound && $$.bound[i])\n                        $$.bound[i](value);\n                    if (ready)\n                        make_dirty(component, i);\n                }\n                return ret;\n            })\n            : [];\n        $$.update();\n        ready = true;\n        run_all($$.before_update);\n        // `false` as a special case of no DOM component\n        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n        if (options.target) {\n            if (options.hydrate) {\n                start_hydrating();\n                const nodes = children(options.target);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.l(nodes);\n                nodes.forEach(detach);\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                $$.fragment && $$.fragment.c();\n            }\n            if (options.intro)\n                transition_in(component.$$.fragment);\n            mount_component(component, options.target, options.anchor, options.customElement);\n            end_hydrating();\n            flush();\n        }\n        set_current_component(parent_component);\n    }\n    /**\n     * Base class for Svelte components. Used when dev=false.\n     */\n    class SvelteComponent {\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    }\n\n    function dispatch_dev(type, detail) {\n        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.4' }, detail), true));\n    }\n    function append_hydration_dev(target, node) {\n        dispatch_dev('SvelteDOMInsert', { target, node });\n        append_hydration(target, node);\n    }\n    function insert_hydration_dev(target, node, anchor) {\n        dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n        insert_hydration(target, node, anchor);\n    }\n    function detach_dev(node) {\n        dispatch_dev('SvelteDOMRemove', { node });\n        detach(node);\n    }\n    function attr_dev(node, attribute, value) {\n        attr(node, attribute, value);\n        if (value == null)\n            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n        else\n            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n    }\n    function validate_slots(name, slot, keys) {\n        for (const slot_key of Object.keys(slot)) {\n            if (!~keys.indexOf(slot_key)) {\n                console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n            }\n        }\n    }\n    /**\n     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n     */\n    class SvelteComponentDev extends SvelteComponent {\n        constructor(options) {\n            if (!options || (!options.target && !options.$$inline)) {\n                throw new Error(\"'target' is a required option\");\n            }\n            super();\n        }\n        $destroy() {\n            super.$destroy();\n            this.$destroy = () => {\n                console.warn('Component was already destroyed'); // eslint-disable-line no-console\n            };\n        }\n        $capture_state() { }\n        $inject_state() { }\n    }\n\n    /* public/index.html generated by Svelte v3.42.4 */\n\n    const file = \"public/index.html\";\n\n    function create_fragment(ctx) {\n    \tlet _DOCTYPE;\n    \tlet t0;\n    \tlet html;\n    \tlet head;\n    \tlet meta0;\n    \tlet t1;\n    \tlet meta1;\n    \tlet t2;\n    \tlet link0;\n    \tlet t3;\n    \tlet link1;\n    \tlet t4;\n    \tlet link2;\n    \tlet t5;\n    \tlet script0;\n    \tlet script0_src_value;\n    \tlet t6;\n    \tlet body;\n    \tlet t7;\n    \tlet script1;\n    \tlet script1_src_value;\n    \tlet t8;\n    \tlet script2;\n    \tlet script2_src_value;\n\n    \tconst block = {\n    \t\tc: function create() {\n    \t\t\t_DOCTYPE = element(\"!DOCTYPE\");\n    \t\t\tt0 = space();\n    \t\t\thtml = element(\"html\");\n    \t\t\thead = element(\"head\");\n    \t\t\tmeta0 = element(\"meta\");\n    \t\t\tt1 = space();\n    \t\t\tmeta1 = element(\"meta\");\n    \t\t\tt2 = space();\n    \t\t\tlink0 = element(\"link\");\n    \t\t\tt3 = space();\n    \t\t\tlink1 = element(\"link\");\n    \t\t\tt4 = space();\n    \t\t\tlink2 = element(\"link\");\n    \t\t\tt5 = space();\n    \t\t\tscript0 = element(\"script\");\n    \t\t\tt6 = space();\n    \t\t\tbody = element(\"body\");\n    \t\t\tt7 = space();\n    \t\t\tscript1 = element(\"script\");\n    \t\t\tt8 = space();\n    \t\t\tscript2 = element(\"script\");\n    \t\t\tthis.h();\n    \t\t},\n    \t\tl: function claim(nodes) {\n    \t\t\t_DOCTYPE = claim_element(nodes, \"!DOCTYPE\", { html: true });\n    \t\t\tt0 = claim_space(nodes);\n    \t\t\thtml = claim_element(nodes, \"HTML\", { lang: true });\n    \t\t\tvar html_nodes = children(html);\n    \t\t\thead = claim_element(html_nodes, \"HEAD\", {});\n    \t\t\tvar head_nodes = children(head);\n    \t\t\tmeta0 = claim_element(head_nodes, \"META\", { charset: true });\n    \t\t\tt1 = claim_space(head_nodes);\n    \t\t\tmeta1 = claim_element(head_nodes, \"META\", { name: true, content: true });\n    \t\t\tt2 = claim_space(head_nodes);\n    \t\t\tlink0 = claim_element(head_nodes, \"LINK\", { rel: true, type: true, href: true });\n    \t\t\tt3 = claim_space(head_nodes);\n    \t\t\tlink1 = claim_element(head_nodes, \"LINK\", { rel: true, href: true });\n    \t\t\tt4 = claim_space(head_nodes);\n    \t\t\tlink2 = claim_element(head_nodes, \"LINK\", { rel: true, href: true });\n    \t\t\tt5 = claim_space(head_nodes);\n    \t\t\tscript0 = claim_element(head_nodes, \"SCRIPT\", { src: true });\n    \t\t\tvar script0_nodes = children(script0);\n    \t\t\tscript0_nodes.forEach(detach_dev);\n    \t\t\thead_nodes.forEach(detach_dev);\n    \t\t\tt6 = claim_space(html_nodes);\n    \t\t\tbody = claim_element(html_nodes, \"BODY\", {});\n    \t\t\tchildren(body).forEach(detach_dev);\n    \t\t\tt7 = claim_space(html_nodes);\n    \t\t\tscript1 = claim_element(html_nodes, \"SCRIPT\", { src: true });\n    \t\t\tvar script1_nodes = children(script1);\n    \t\t\tscript1_nodes.forEach(detach_dev);\n    \t\t\tt8 = claim_space(html_nodes);\n    \t\t\tscript2 = claim_element(html_nodes, \"SCRIPT\", { src: true });\n    \t\t\tvar script2_nodes = children(script2);\n    \t\t\tscript2_nodes.forEach(detach_dev);\n    \t\t\thtml_nodes.forEach(detach_dev);\n    \t\t\tthis.h();\n    \t\t},\n    \t\th: function hydrate() {\n    \t\t\tattr_dev(_DOCTYPE, \"html\", \"\");\n    \t\t\tadd_location(_DOCTYPE, file, 0, 0, 0);\n    \t\t\tattr_dev(meta0, \"charset\", \"utf-8\");\n    \t\t\tadd_location(meta0, file, 3, 4, 46);\n    \t\t\tattr_dev(meta1, \"name\", \"viewport\");\n    \t\t\tattr_dev(meta1, \"content\", \"width=device-width,initial-scale=1\");\n    \t\t\tadd_location(meta1, file, 4, 4, 75);\n    \t\t\tattr_dev(link0, \"rel\", \"icon\");\n    \t\t\tattr_dev(link0, \"type\", \"image/png\");\n    \t\t\tattr_dev(link0, \"href\", \"/favicon.png\");\n    \t\t\tadd_location(link0, file, 6, 4, 150);\n    \t\t\tattr_dev(link1, \"rel\", \"stylesheet\");\n    \t\t\tattr_dev(link1, \"href\", \"/global.css\");\n    \t\t\tadd_location(link1, file, 7, 4, 211);\n    \t\t\tattr_dev(link2, \"rel\", \"stylesheet\");\n    \t\t\tattr_dev(link2, \"href\", \"/build/bundle.css\");\n    \t\t\tadd_location(link2, file, 8, 4, 260);\n    \t\t\tscript0.defer = true;\n    \t\t\tif (!src_url_equal(script0.src, script0_src_value = \"/build/bundle.js\")) attr_dev(script0, \"src\", script0_src_value);\n    \t\t\tadd_location(script0, file, 10, 4, 316);\n    \t\t\tadd_location(head, file, 2, 2, 35);\n    \t\t\tadd_location(body, file, 13, 2, 376);\n    \t\t\tif (!src_url_equal(script1.src, script1_src_value = \"http://code.jquery.com/jquery-latest.min.js\")) attr_dev(script1, \"src\", script1_src_value);\n    \t\t\tadd_location(script1, file, 14, 2, 392);\n    \t\t\tif (!src_url_equal(script2.src, script2_src_value = \"../chat.js\")) attr_dev(script2, \"src\", script2_src_value);\n    \t\t\tadd_location(script2, file, 15, 2, 462);\n    \t\t\tattr_dev(html, \"lang\", \"en\");\n    \t\t\tadd_location(html, file, 1, 0, 16);\n    \t\t},\n    \t\tm: function mount(target, anchor) {\n    \t\t\tinsert_hydration_dev(target, _DOCTYPE, anchor);\n    \t\t\tinsert_hydration_dev(target, t0, anchor);\n    \t\t\tinsert_hydration_dev(target, html, anchor);\n    \t\t\tappend_hydration_dev(html, head);\n    \t\t\tappend_hydration_dev(head, meta0);\n    \t\t\tappend_hydration_dev(head, t1);\n    \t\t\tappend_hydration_dev(head, meta1);\n    \t\t\tappend_hydration_dev(head, t2);\n    \t\t\tappend_hydration_dev(head, link0);\n    \t\t\tappend_hydration_dev(head, t3);\n    \t\t\tappend_hydration_dev(head, link1);\n    \t\t\tappend_hydration_dev(head, t4);\n    \t\t\tappend_hydration_dev(head, link2);\n    \t\t\tappend_hydration_dev(head, t5);\n    \t\t\tappend_hydration_dev(head, script0);\n    \t\t\tappend_hydration_dev(html, t6);\n    \t\t\tappend_hydration_dev(html, body);\n    \t\t\tappend_hydration_dev(html, t7);\n    \t\t\tappend_hydration_dev(html, script1);\n    \t\t\tappend_hydration_dev(html, t8);\n    \t\t\tappend_hydration_dev(html, script2);\n    \t\t},\n    \t\tp: noop,\n    \t\ti: noop,\n    \t\to: noop,\n    \t\td: function destroy(detaching) {\n    \t\t\tif (detaching) detach_dev(_DOCTYPE);\n    \t\t\tif (detaching) detach_dev(t0);\n    \t\t\tif (detaching) detach_dev(html);\n    \t\t}\n    \t};\n\n    \tdispatch_dev(\"SvelteRegisterBlock\", {\n    \t\tblock,\n    \t\tid: create_fragment.name,\n    \t\ttype: \"component\",\n    \t\tsource: \"\",\n    \t\tctx\n    \t});\n\n    \treturn block;\n    }\n\n    function instance($$self, $$props) {\n    \tlet { $$slots: slots = {}, $$scope } = $$props;\n    \tvalidate_slots('Public', slots, []);\n    \tconst writable_props = [];\n\n    \tObject.keys($$props).forEach(key => {\n    \t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Public> was created with unknown prop '${key}'`);\n    \t});\n\n    \treturn [];\n    }\n\n    class Public extends SvelteComponentDev {\n    \tconstructor(options) {\n    \t\tsuper(options);\n    \t\tinit(this, options, instance, create_fragment, safe_not_equal, {});\n\n    \t\tdispatch_dev(\"SvelteRegisterComponent\", {\n    \t\t\tcomponent: this,\n    \t\t\ttagName: \"Public\",\n    \t\t\toptions,\n    \t\t\tid: create_fragment.name\n    \t\t});\n    \t}\n    }\n\n    return Public;\n\n}());\n",
      "dynamicImports": [],
      "exports": ["default"],
      "facadeModuleId": "/home/dhairy/Desktop/gh/projects/chatapp-svelte/public/index.html",
      "fileName": "index.js",
      "imports": [],
      "isDynamicEntry": false,
      "isEntry": true,
      "map": null,
      "modules": {
        "/home/dhairy/Desktop/gh/projects/chatapp-svelte/node_modules/svelte/internal/index.mjs": {
          "originalLength": 67628,
          "removedExports": [
            "HtmlTag",
            "HtmlTagHydration",
            "SvelteComponentTyped",
            "SvelteElement",
            "action_destroyer",
            "add_attribute",
            "add_classes",
            "add_flush_callback",
            "add_resize_listener",
            "add_transform",
            "afterUpdate",
            "append",
            "append_dev",
            "append_empty_stylesheet",
            "append_styles",
            "assign",
            "attribute_to_object",
            "beforeUpdate",
            "bind",
            "bubble",
            "check_outros",
            "claim_component",
            "claim_html_tag",
            "claim_svg_element",
            "clear_loops",
            "component_subscribe",
            "compute_rest_props",
            "compute_slots",
            "createEventDispatcher",
            "create_animation",
            "create_bidirectional_transition",
            "create_component",
            "create_in_transition",
            "create_out_transition",
            "create_slot",
            "create_ssr_component",
            "dataset_dev",
            "debug",
            "destroy_block",
            "destroy_each",
            "detach_after_dev",
            "detach_before_dev",
            "detach_between_dev",
            "each",
            "element_is",
            "empty",
            "escape",
            "escape_attribute_value",
            "escape_object",
            "escaped",
            "exclude_internal_props",
            "fix_and_destroy_block",
            "fix_and_outro_and_destroy_block",
            "fix_position",
            "getAllContexts",
            "getContext",
            "get_all_dirty_from_scope",
            "get_binding_group_value",
            "get_current_component",
            "get_custom_elements_slots",
            "get_root_for_style",
            "get_slot_changes",
            "get_spread_object",
            "get_spread_update",
            "get_store_value",
            "globals",
            "group_outros",
            "handle_promise",
            "hasContext",
            "has_prop",
            "identity",
            "insert",
            "insert_dev",
            "intros",
            "invalid_attribute_name_character",
            "is_client",
            "is_crossorigin",
            "is_promise",
            "listen",
            "listen_dev",
            "loop",
            "loop_guard",
            "missing_component",
            "not_equal",
            "now",
            "null_to_empty",
            "object_without_properties",
            "onDestroy",
            "onMount",
            "once",
            "outro_and_destroy_block",
            "prevent_default",
            "prop_dev",
            "query_selector_all",
            "raf",
            "select_multiple_value",
            "select_option",
            "select_options",
            "select_value",
            "self",
            "setContext",
            "set_attributes",
            "set_custom_element_data",
            "set_data",
            "set_data_dev",
            "set_input_type",
            "set_input_value",
            "set_now",
            "set_raf",
            "set_store_value",
            "set_style",
            "set_svg_attributes",
            "spread",
            "stop_propagation",
            "subscribe",
            "svg_element",
            "tick",
            "time_ranges_to_array",
            "to_number",
            "toggle_class",
            "transition_out",
            "trusted",
            "update_await_block_branch",
            "update_keyed_each",
            "update_slot",
            "update_slot_base",
            "validate_component",
            "validate_each_argument",
            "validate_each_keys",
            "validate_store",
            "xlink_attr"
          ],
          "renderedExports": [
            "SvelteComponent",
            "SvelteComponentDev",
            "add_location",
            "add_render_callback",
            "append_hydration",
            "append_hydration_dev",
            "attr",
            "attr_dev",
            "binding_callbacks",
            "blank_object",
            "children",
            "claim_element",
            "claim_space",
            "claim_text",
            "current_component",
            "custom_event",
            "destroy_component",
            "detach",
            "detach_dev",
            "dirty_components",
            "dispatch_dev",
            "element",
            "end_hydrating",
            "flush",
            "init",
            "insert_hydration",
            "insert_hydration_dev",
            "is_empty",
            "is_function",
            "mount_component",
            "noop",
            "run",
            "run_all",
            "safe_not_equal",
            "schedule_update",
            "set_current_component",
            "space",
            "src_url_equal",
            "start_hydrating",
            "text",
            "transition_in",
            "validate_slots"
          ],
          "renderedLength": 18593
        },
        "/home/dhairy/Desktop/gh/projects/chatapp-svelte/public/index.html": {
          "originalLength": 505,
          "removedExports": [],
          "renderedExports": ["default"],
          "renderedLength": 5812
        }
      },
      "name": "index",
      "type": "chunk"
    },
    "watchFiles": [
      "/home/dhairy/Desktop/gh/projects/chatapp-svelte/public/index.html",
      "/home/dhairy/Desktop/gh/projects/chatapp-svelte/node_modules/svelte/internal/index.mjs"
    ]
  },
  "hashes": {
    "js": "96c9800e47c243ebcec4a5c683470f7b"
  }
}
